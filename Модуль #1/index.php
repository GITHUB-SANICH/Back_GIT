<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Тайтл</title>
</head>

<body></body>
<header>
	Шапка сайта
</header>
<footer>Подвал сайта</footer>
<?php
echo '<hr><hr><br><h2>Модуль №1: Введение в Back-end. PHP Основы
</h2>' . "<br>";
echo '<hr><hr><br><h3>Back - #1.10-15 - Генератор «yield»</h3><hr><hr>' . "<br>";
/*Введение:
Генератор - это функция способная вернуть сразу множество значений в отличии от обычной функции, возращающей одно значение.
Кроме того генератор сохраняет значение последней итерации при повторном обращении к ней и позволяет ее выводить при выходе из функции (генератора).
Функция же при выходе выдает лишь одно значение, когда как генератор выдает их после каждой итерации.
В генераторах используется ключевое слово yield вместо слова return. Оно ведет себя похожим образом, и возвращает значение в точку вызова, с тем отличием, что функция (уже генератор) не удаляется из стека, а ее состояние сохраняется в памяти. Это позволяет функции(генератору) продолжить работу с предыдущего состояния при следующем ее вызове. На самом деле, вы не можете использовать ключевое слово return для возврата значения из генератора, а для того, чтобы прекратить выполнение генератора.

	ФУНКЦИИ ЗАДЕЙСТВОВАННЫЕ ПРИ РАБОТЕ ГЕНЕРАТОРА:
	current(); - Функция/метод просто возвращает значение элемента массива, на который указывает его внутренний указатель. Она не перемещает указатель куда бы то ни было. Если внутренний указатель находится за пределами списка элементов или массив пуст, current() возвращает false.
	next(); - функкция/методведёт  передвигает его внутренний указатель на одну позицию вперёд. Другими словами, она возвращает следующий элемент массива и сдвигает его внутренний указатель на одну позицию (на одну итеррацию вперед).

	Создадим функцию с циклом внутри
*/
//создадим генератор
function gena()
{
	for ($i = 1; $i <= 5; $i++) {
		//return $i; - 
		yield $i; //аналог return, позволявший выводить множество значенией функции поочередно
	}
}

$g_move = gena();
echo 'Вывод значенний генератора: ' . $g_move->current() . '<br>';
$g_move->next();
echo 'Вывод значенний генератора: ' . $g_move->current() . '<br>';
$g_move->next();
echo 'Вывод значенний генератора: ' . $g_move->current() . '<br>';
$g_move->next();
echo 'Вывод значенний генератора: ' . $g_move->current() . '<br>';
$g_move->next();

/*Тоже самое можно было бы записать через цикл While:
$g_move = gena();
while ($a <= 10) {
	echo 'Вывод значенний генератора: ' . $g_move->current() . '<br>';
	$g_move->next();
}*/
echo '<hr><hr><br><h3>Back - #1.11 - Переменные переменных</h3><hr><hr>' . "<br>";
/*Введение:
Это просто ознакомление с приемом в php.
Вывести значение переменной возможно через вывоз названия переменной, складываемое из других переменных.
	СИНТАКСИС ВЫВОДА "СБОРНОЙ ПЕРЕМЕННОЙ":
	${''}
	где, $ - объявление переменной, {} - границы названия переменной. 
	1-й вариант: вызов через скрепление переменных - ${$a . $b} 
	2-й вариант: вызов через указание названия переменной в виде строки - ${'peremenn'}
	3-й вариант: вызов переменной в виде переменной, собравший переменные с частями собераемой переменной - ${$a_b} 
	4-й вариант: вызов переменной из 3-го варианта, но через указание 2-го знака доллара - $$a_b. Второй доллар применяется только к переменным.
*/
//СОздадим переменную и выведем ее
$peremenn = 'hallo word';
$a = 'pere';
$b = 'menn';
$a_b = $a . $b;
echo 'Сборная переменная #1: ' . ${$a . $b} . '<br>';
echo 'Сборная переменная #2: ' . ${'peremenn'} . '<br>';
echo 'Сборная переменная #3: ' . ${$a_b} . '<br>';
echo 'Сборная переменная #4: ' . $$a_b . '<br>';


echo '<hr><hr><br><h3>Back - #1.12 - Передача данных по ссылке</h3><hr><hr>' . "<br>";
/*Введение:
Создадим для начала функцию передачи данных через функцию, а затем по ссылке для сравнения. 
Все значения внутри функцииполученные в результате операции внутри нее остаются невидимыми ща пределами функции. 
Т.е. если внутри функции пррибавить к чилу "5" еще "1", то при вызове переменной будет выводиться 5 если не использовать функциию обращения к глобальной переменной "global", той, что находится вне функции. 
Для вывод результата сложения либо выводить его внутри функции. 
Либо ссылаться на переменную сразу при вызове функции, через знак амперсанта. 
Тогда функция соединяется с глобальной переменной напрямую без обращения к функции "global";
Пример:
function test(&$var){
	$var++;
}

$var = 6;
test($var );
При выводе переменной $var на экране будет видна 7-ка.
*/
//функция передачи данных
function test(&$var)
{
	$var++;
}

$a = 9;
test($a);
echo 'Вывод переменной через ссылку к глобальной переменной (&+$a): ' . $a;

echo '<hr><hr><br><h3>Back - #1.16 - Конструкция «try catch»</h3><hr><hr>' . "<br>";
/*Введение:
В ходе урока будет рассмотрены "исключения" и конструкция «try catch». Позже рассотрм ее назначение подробнее. 
Одно из направлений конструкции «try catch» это отслеживание фатальных (и нет) ошибок и оповещении о них пользователей в более удобоваримом виде.
Например это могут быть ошибки деления на ноль или отсутствие открываемого файла или при указании неверных настроек при подключении к БД.
При задействии этой конструкции и при наличии фатальной ошибки - код будет продолжать выполняться дальше.

	СОСТАВ КОНСТРУКЦИИ
	1) Внутрь блока "try" помещается код, который предположительно имеет ошибку. 
	2) Внутрь круглых скобок () "catch" помещается предпологаемый класс ошибки и дополнительно переменная (объект), вмещающая в себя информацию о ошибке, которая выводилась бы если бы конструкция «try catch» не прописывалась бы. Но так как эта переменная - объект, то через нее можно обратиться к функции вывода
		Внутри фигурных скобок - это код, срабатывающий в результате ошибке, класс которой указан в блоке "try". 
		Пример:
		echo $th->getMessage();				//Обращение к методу вывода сокращенной информации об ошибке
		В них можно ничего не прописывать, но тогда и смысла в написании конструкции нет.
		Блок "catch" может повторяться множество раз подрят по числу классов, отслеживаемых ошибок.
	3) Внутри НЕОБЯЗАТЕЛЬНОГО блока "finally" находится код, выполняющийся всегда. 
	И в результате выполнения кода в блоке "try" (отсутствие ошибок) или внутри блока "catch" (когда ошибки есть).
	Этот блок нужен например при открытии файлов. Потому, точ всегда после открытия файла - его нужно закрывать. 
	То есть если файл будет отсутствовать - срабатывает ошибка о отсутствии файла и файл закрывается, либо файл найден и открыт и после в блоке "finally" закрывается.

	ВЫБРАСЫВАНИЕ СООБЩЕНИЯ ОБ ОШИБКЕ БЕЗ КОНСТРУКЦИИ «try catch»
	Однако ошибки можно выдавать без обращении к конструкции «try catch». 
	Для этого достаточно после условия предпологаемой ошибки прописать ключевое слово "throw" которое позволяет создать объект на основе класса с ошибкой. 
	После слова "new" прописывается класс ошибки (например "DivisionByZeroError"). 
	Внутри скобок () после класса ошибки прописывается сообщение при наличии ошибки этого класса.
	Пример:
	Сначала было прописано сообщение  ошибки Exception: ('Универсальный класс ошибки #1<br>');
	Это сообщение заменило стандартный текст оповещения об ошибке и перенесено в переменную $e.
	echo 'Универсальный класс ошибки #2<br>' . $e->getMessage();
	Сначала выводится сообщение написанное в блоке "catch", а затем через обращение к методу вызова сообщения, 
	написанного еще при написании условия: throw new Exception('Сообщение при ошибке "Exception" #1<br>');

*/

function divid()
{
	$a = 5;
	$b = 0;
	if ($b == 0 || $a == 0) {
		throw new Exception('Сообщение при ошибке "Exception" #1<br>');	//сообщения при ошибке определенного класса
	}

	return $a / $b;
}

try {
	divid();
} catch (DivisionByZeroError $th) { //Класс DivisionByZeroError - отслеживает ошибки при попытке деления на ноль.
	echo $th->getMessage();				//Обращение к методу вывода сокращенной информации об ошибке
} catch (Exception $e) {				//Класс Exception - унимерсальный класс отслеживающий любые ошибки фатальные и нефатальные.
	echo 'Универсальный класс ошибки #2<br>' . $e->getMessage(); // Вывод сначало написанного текста, а затем текста, который был объявлен еще после блока условия if.
} finally {
	echo '<br>Гарантированный код блока "finally"<br>';
}

?>
</body>

</html>