<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Тайтл</title>
</head>

<body></body>
<header>
	Шапка сайта
</header>
<footer>Подвал сайта</footer>
<?php
echo '<hr><hr><br><h2>Модуль №3: База данных MySQL
</h2>' . "<br>";
echo '<hr><hr><br><h3>Back - #3.4-5 - Изучение системы по управлению БД – PostgreSQL</h3><hr><hr>' . "<br>";
/*Введение:
PostgreSQL - это альтернативная  СУБД для MySQL.
Она более строгая и делает больше проверок за вас, что дает меньше шансов ошибиться - что есть приемущество. 
Во всяком случаи знать синтаксис нескольких СУБД лучше чем незнать. 

ВНИМАНИЕ! Я не буду записывать в этом документе содержание уроков с СУБД PostgreSQL, так как на работеи в заданиях этого не требуется.
*/
echo '<hr><hr><br><h3>Back - #3.5 - SQL команды. Конфликты, внешние ключи, объединения</h3><hr><hr>' . "<br>";
/*Введение:
В ходе уроке будут рассмотрены SQL команды без привязки к языку программирования в графическом интерфейсе "phpMyAdmin". 
Для начала создадим новую БД и заполним ее таблицу данными:
а)"CREATE DATABASE `sql_testing(nobackend)`" - создание БД
б) Создаем в ней таблицу "buyers" (покупатель).
в) Заполняем ее данными: INSERT INTO `bayers`(`age`, `name`, `price`) VALUES (30, 'Jhon', 450), (20, 'Bane', 300), (24, 'Myke', 450), (32, 'Georg', 110).

КОНФЛИКТЫ:
Допустим во время выполнения SQL команды происходит ошибка (конфликт).
В СУБД существует что-то вроеде исключений или условных операторов, которые при возникновении конфликта выполняют другой запрос. 
Создадим запрос с ошибкой (с указанием сущуствующего id):
INSERT INTO `bayers`(`id`, `age`, `name`, `price`) VALUES (3, 14, 'Leha', '550') ON DUPLICATE KEY UPDATE `age` = 22 ... ,
Где,
ON - оператор отслеживания конфликтов 
DUPLICATE - при наличии уже имеющихся данных
KEY UPDATE `` - обновить определенные поля 
Что означает - в случаи конфликта поменять только значение овзраста на 22.

ВНЕШНИЙ КЛЮЧ:
Внешний ключ позволяет создать поле записи внутри которого всегда ссылаются на поле из другой таблици.
Создадим вторую таблицу:
CREATE TABLE parent (
	id INT NOT NULL,
    PRIMARY KEY (id)
) ENGINE = INNODB
Где,
CREATE TABLE parent	- создание таблицы parent
id INT NOT NULL		- id не пустое
PRIMARY KEY (id)		- поле id является первичным ключем 
ENGINE = INNODB		- движок на котором создается таблица
INNODB					- движок INNODB позволяет создавать поля, ссылающиеся на поля из других таблиц. 
ВНИМАНИЕ! С движком MyISAM такие поля создать нельзя.
Если не указывать движок при создании таблицы, то по-умолчанию выбирается движок "InnoDB".
Таблица создается с одним полем, которое является первичным ключом. 

Создадим еще одну таблицу, поле которой будет ссылаться на поле предыдущей таблицы:
CREATE TABLE child (
	id INT NOT NULL,
    parent_id INT,
    PRIMARY KEY (id),
    FOREIGN KEY (parent_id)
    	REFERENCES parent(id)
                 ON DELETE CASCADE
) ENGINE = INNODB
Где,
parent_id INT				- поле, которое будет ссылаться на значение предыдущей таблицы
FOREIGN KEY (parent_id)	- объявление для поля (parent_id) внешнего ключа, позволяющего ссылаться на значение из других таблицы
REFERENCES parent(id)	- поле из предыдущей таблицу на которое будет ссылаться поле с внешним ключом из новой таблице 
ON DELETE CASCADE			- конфликт: при удалени значения из предыдущей таблице - это значение из новой таблицы тоже удаляется

Добвим несколько значений id в 1-ю таблицу, и при добавлении строк в 2-ю таблицу - в поле parent_id предлагается выбрать одно из значений поля id 1-й таблицы. Без указания значения запрос не читается. Выбранная диталь является ссылкой на поле 1-й таблицы.


ПРАКТИЧЕСКОЕ ПРИМЕНЕНИЕ ВНЕШНИХ КЛЮЧЕЙ
Создадим несколько дополнительных таблицы (users, items, orders) ... 
У третей таблице (заказы) будут внешние ключи - т.е. она будет ссылаться на другие таблицы (покупателей и их заказы).
CREATE TABLE users (покупатели) (
	id INT(11) NOT NULL AUTO_INCREMENT,
    age INT(5) NOT NULL,
    name VARCHAR(50)NOT NULL,
    PRIMARY KEY (id)
) ENGINE = INNODB
Где,
AUTO_INCREMENT - автозаполнение поля при добавлении новой сторки в таблице

CREATE TABLE items (товары) (
	 id INT(11) NOT NULL AUTO_INCREMENT, 
	 price INT(5) NOT NULL, 
	 name VARCHAR(50)NOT NULL, 
	 PRIMARY KEY (id) 
) ENGINE = INNODB 

CREATE TABLE orders (заказы) ( 
INSERT INTO `orders` (`userId`, `itemId`) VALUES (3, 2), (1, 4), (2, 1), (4, 3);
Где,
userId - поле с id купившего пользователя
itemId - поле с id купленного предмета
FOREIGN KEY (userId) REFERENCES users (id) - поле с внешнем ключем (userId) ссылается на поле (users) из таблице пользователй
FOREIGN KEY (itemId) REFERENCES items (id) - поле с внешнем ключем (itemId) ссылается на поле (items) из таблице пользователй

Добавим в таблицу товаров несколько записей через интерфейс MySQL.
Добавим в таблицу пользователй несколько записей. 
При добавлении полей в таблицу закупок - поля с внешними ключами можно заполнть только значениями из других таблиц. 
	При том в двух форматах: id - имя либо имя - id. Это в первом поле. 
Во втором поле так же.
такой формат записи в таблицах существенно сокращает таблицы данных, что положительно сказывается на оптимизации. 

Теперь добавим несколько строк в таблицу
INSERT INTO `orders` (`userId`, `itemId`) VALUES (3, 2), (1, 4), (2, 1), (4, 3);
Где, 
Первая строка: пользователь номер 3 купил товар номер 2.
Теперь все поля кроме id строки в таблице закупок являются ссылками на другие таблицы - 
при наведении на них отображаются имена или товары.

Внешние ключи и первичные ключи можно добавлять через SQL команду уже в созданную таблицу, а не как до этого мы добавляли в создаваемую.
Для этого пропишем (но не выполним запрос) запрос:
ALTER TABLE `items` ADD 
PRIMARY KEY (`id`)
FOREIGN KEY (itemId) REFERENCES users (id),
INDEX (`id`) 
Где,
ALTER TABLE - добавление к таблице

Таким же образом можно все это удалять:
ADD TABLE `items` DROP PRIMARY KEY (`id`)
Где, 
DROP PRIMARY - удаление свойства первичного ключа у поля id

ОБЪЕДИНЕНИЕ В ЯЗЫКЕ SQL
Объединение это свойство СУБД SQL, позволяющее выводить данные сразу из нескольких таблицы, 
	при указании определенных условий 
Зайдем атаблицу закопок и через строку запроса пропишем все что нужно для объединения:
SELECT * FROM `orders` 
JOIN `users` ON orders.userId = users.id 
JOIN `items` ON items.id = orders.itemId

Пример объединения №1:
Вывести все поля из таблицы закупок и объединить с таблицей  users, 
	где поля userId из таблице orders совпадают с полями id из таблици users,
	и объеденить с таблицей items, где поле id из таблицы items ровно полю itemId из таблицы orders.
Где,
SELECT * FROM `orders`		- выбиаем все поля из таблице закупок
JOIN								- объединение с таблицей в которой хранится полная информация по покупателю
ON 								- начало условия
orders.userId = users.id	- условия соединения таблиц
Благодаря этому запросу выводится информация без необходимости лазать по таблицам 

Пример объединения №2(вывод имен покупателей и названий покупок):
SELECT users.name AS 'Имя покупателя', items.name AS 'Название товара', items.price AS 'Цена товара' FROM `orders`
JOIN `users` ON users.id = orders.userId
JOIN `items` ON items.id = orders.itemId
Вывести из таблицы пользователи поле имя покупателя и поле название товара из таблицы товары, 
	выбирать все это из таблицы закупки совпадает с таблицей пользователи по условия: id пользователя совпадает с полем userId из таблицы orders.
*Условие интеренсо тем, что в таблице закупок (orders) нет информации о именах пользователя и названиях товаров. Только ссылки на таблицы пользователей и товаров.
Где,
AS - замена поле на псевдоним

Пример объединения №3(вывод имен покупателей и общей суммы отданных на товары):
SELECT (users.name AS 'Имя покупателя', SUM(items.price) AS 'Общий чек') FROM `orders` 
JOIN `users` ON users.id = orders.userId 
JOIN `items` ON items.id = orders.itemId 
GROUP BY orders.userId 
HAVING SUM(items.price) > 10000
Где,
SUM(items.price) 			- суммирование всех значений 
GROUP BY orders.userId  - сгруппировать все поля с одинаковым id в одну строку
HAVING SUM(items.price)	- из всех полученных записей вывести те, которые имет общую сумму более 10к

Пример объединения №4(вывод имен покупателей и общей суммы отданных на товары в расширенном виде):
SELECT CONCAT ('Имя пользователя: ', UCASE(users.name), '. Общая стоимость: ', SUM(items.price)) AS 'Полная информация: ' FROM `orders` 
JOIN `users` ON users.id = orders.userId 
JOIN `items` ON items.id = orders.itemId 
GROUP BY orders.userId 
HAVING SUM(items.price) > 10000
Где,
CONCAT		- оператор, позволяющий внетрять тескстовые вставки в запрос
UCASE			- оператор, выстраивающий все символы в верхний регистр


СПИСОК SQL-КОМАНД:
ON					- оператор условия
DUPLICATE		- условие, срабатываемое при ошибке повторяющегося уникального значения
PRIMARY KEY		- поля является первичным ключем (поле в таблице, которое однозначно идентифицирует каждую строку/запись в таблице)
AUTO_INCREMENT - автозаполнение поля при добавлении новой сторки в таблице
ENGINE			- движок на основе которого работает таблицы 
FOREIGN KEY		- объявление поля, которое ссылается на поле из другой таблицы (это внешний ключ). 
REFERENCES		- объявляет поле на которое ссылается поле создаваемой таблицы.
DELETE CASCADE - удаление значений из поля индекса в случаи удаления его в поле ключевого поля из предыдущей таблицы
ALTER TABLE		- добавление к таблице 
INDEX				- объявление поля индексом (поля индексы грузятся чуть быстрее обычного поля)
DROP PRIMARY 	- удаление свойства первичного ключа/индекса/внешнего ключа и т.п.
JOIN				- объединение 
AS 				- замена поле на псевдоним
SUM() 			- суммирование всех значений 
GROUP BY 	  	- сгруппировать все поля в одну
HAVING			- оператор условия. Предложение HAVING используется только с SELECT. HAVING обычно используется с предложением GROUP BY. 
CONCAT			- оператор, позволяющий внетрять тескстовые вставки в запрос
UCASE				- оператор, выстраивающий все символы в верхний регистр
*/

?>
</body>

</html>