<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Тайтл</title>
</head>

<body></body>
<header>
	Шапка сайта
</header>
<footer>Подвал сайта</footer>
<?php
echo '<hr><hr><br><h2>Модуль №2: PHP Продвинутый (ООП)
</h2>' . "<br>";
echo '<hr><hr><br><h3>Back - #2.7-10 - Ключевое слово «final»</h3><hr><hr>' . "<br>";
/*Введение:
Для разбора ключевого слова «final» напирем структуру.
Создадим два класса: родителя/наследника. 
«final» - коротко: это модефикатор доступа, который запрещает наследовать элементы либо запрещает иметь наследников совсем.  
Если навесить такой модефикатор на класс родителя, то у него не может быть наследников. 
Либо если прописать этот модефикатор к функции, то наследники не могут обращаться к финкции родителя обрамленнной модефикатором «final». Наследнику нельзя будет обращаться к этому методу, даже если он будет скопирован у родителя без модефикатора «final». Будет выводиться ошибка.
Пример: 
final class Base { 				- этот класс не может иметь наследников, его методы не нас
public function printDate(){	- этот метод не может быть использован наследниками, даже если он будет перенесен внутрь них

*/
//Класс родителя (Base)
class Base {
	public /*final*/ function printDate(){			// - не наследуемый метод
		echo "Вызван метод Base::printDate()<br>";
	}
}
//Класс наследника (Child)
class Child extends Base {
	public function printDate(){						// - вызов метода выдает ошибку даже при дублировании метода внутрь наследника
		echo "Вызван метод Base::printDate()<br>";
	}
}
//вызов объекта наследника
$obj = new Child();
$obj -> printDate();


echo '<hr><hr><br><h3>Back - #2.8 - Магические методы</h3><hr><hr>' . "<br>";
/*Введение:
	Магисечкие методы - это методы, которые переопределяют действия PHP по умолчанию. 
	Грубо говоря магический метод - это метод, который срабатывает при определенных условиях. То бишь ссылка на несуществующий файл, удаление объекта, 
	Конструкто/рдеструктор классов это тожe магические методы, так как переопределяет стандартные действия. 
	Все магические методы начинаются с двух подчеркиваний. 
	Пример: 
	__construct(){}, __destruct(){}.


	Внимание! Все магические методы, за исключением __construct(), __destruct() и __clone(), ДОЛЖНЫ быть объявлены как public, в противном случае будет вызвана ошибка уровня E_WARNING. 
	До PHP 8.0.0 для магических методов __sleep(), __wakeup(), __serialize(), __unserialize() и __set_state() не выполнялась проверка.

	МАГИЧЕСКИЕ МЕТОДЫ:
		__construct(); - конструктор вызывается при создании объекта или при начале работы с объектом. Так же через конструктор поля классов заполняются данными при создании этих полей.
		__destruct(); - деструктор при удалении объекта или в конце работы с объектом.
		Связка магических метдов "construct" и "destruct" может пригодиться, когда нужно подключиться к БД ипри выходе из нее прирвать соединение с ней.

		__call(); - вызывается при обращении к несуществующему методу внутри класса. Вроде оповещения об ошибке.
			Этот метод работает при наличии двух аргументов. И работает только с нестатичными методами.
			Первый аргумент это название искомого метода. Второй - это параметры этого метода (аргументы). 
		__callStatic(); - это метод аналогичный методу "__call()", но работающий только со статическими методами.
			Этот метод так же принимает в себя два аргумента.
			Иэтот метод является тоже статичным. 
			Пример:
			static function __callStatic($m_name, $m_val){}
		Магические методы "call" и "callStatic" отлично подходят для отслеживания несуществующих статических и нестатических методов. 

		__get(); - это магический метод, срабатывающий когда запрашиваемое поле не находится. Либо если поле 			имеется, но у него защитный или приватный модефикатор доступа (недоступно). Единственным аргументом 		выступает название поля.
		__set(); - это магический метод, срабатывающий при попытке изменить значение поля, имеющего защитный либо приватный модефикатор доступа.
			Первым аргументом выступает переименовываемое поле. Вторым аргементом новое значение переименовываемого поля.
		
		__isset(); - метод, срабатывающий при попытке найти несуществующее или закрытое/приватное поле через функцию isset(); или empty();
			Единственным аргументом выступает связка обращающегося общекта и несущестующего метода 
			Пример: isset($obj_1->arg);
		__unset(); - метод, срабатывающий при попытке удалить несуществующее или закрытое/приватное поле через функцию unset(); 
			Единственным аргументом выступает название удаляемого поля. 

		__toString(); - метод, срабатывающий при попытке вывода поля на экран. Попытка вывода поля без этого магического объекта вызывает ошибку. Этот метод используется для вывода значения поля при попытке его вывода без обращения к методукласса. 
		Вывод значения поля прописанный внутри магического метода.
		
		__invoke(); - метод срабатывающий при попытке вызова объекта в качестве функции. 
			Пример: $obj('gg');
			Аргументом выступает значение, которое передавалось объекту. Если передавался массив в качестве аргумента, то и аргументов магического объекта будет по числу значений массива. Если из массива нужно вывести первые два значения из 5-ти, то в методе указываются два аргумента. 
		*/
class Base_1 {
	private $name = 'get_pole';
	function __construct(){		//пример магического метода						
		echo "Объект добавлен через конструктор или его работа начата<br>";
	}
	//срабатывает при обращении
	function print(){
		echo "Тест объекта<br><br>";
	}
	//срабатывает при попытке найти несуществующий метод
	function __isset($iss_metod){
		echo "<br>Метод не найден:<br><b>Название: $iss_metod</b><br>";
	}
	//срабатывает при отсутствии искомых полей
	function __get($g_name){
		echo "<br><br>Поле не найдено:<br><b>Название: $g_name</b><br>";
	}
	//срабатывает при попытке редактировании защищенных полей
	function __set($s_name, $s_arg){
		echo "<br>Поле недоступно:<br><b>Название: $s_name</b><br><b>Значение: $s_arg </b><br>";
	}
	//срабатывает при попытке удаления защищенных полей
	function __unset($un_name){
		echo "<br>Поле недоступно:<br><b>Название: $un_name</b><br>";
	}
	//срабатывает при отсутствии искомых методов
	function __call($m_name, $m_val){
		echo "Метод в классе не найден:<br><b>Название: $m_name </b><br><b>Значение: $m_val </b><br>";
		print_r($m_val);
	}
	//срабатывает при отсутствии искомых стиатических методов
	static function __callStatic($m_name, $m_val){
		echo "<br><br>Статический метод в классе не найден:<br><b>Название: $m_name </b><br><b>Значение: $m_val </b><br>";
		print_r($m_val);
	}
	//срабатывает при попытке вызова поля
	function __toString(){
		return "<br>Попытка вывода поля:<br><b>Значение переменной: $this->name</b><br>";
	}
	//срабатывает при попытке вызова поля как функцию
	function __invoke($a_in, $b_in, $c_in){
		echo "Попытка вызова поля как функцию:<br><b>Значение аргумента(ов): $a_in, $b_in, $c_in </b><br>";
	}
	function __destruct(){	
		echo "<br>Объект удален через диструктор либо его работа завершена<br>";
	}
}

$obj_1 = new Base_1();  //выделенеи памяти в классе для нового объекта
$obj_1->print(1,2,3); //обращение к существующему методу
$obj_1->non(1,2,3); //обращение к несуществующему методу
Base_1::stat(3,2,1); //обращение к несуществующему статическому методу в классе "Base_1"
echo $obj_1->name; // вызов приватного поля
$obj_1->name = 'New_name'; //попытка изменить приватное поле
isset($obj_1->arg); //попытка найти несуществующий метод
unset($obj_1->arg); //попытка найти несуществующий метод
echo $obj_1.'<br>';	//попытка вызова объекта
$obj_1('ГГ', 'ВП', 10);			//попытка вызова объекта как функцию

echo '<hr><hr><br><h3>Back - #2.9 - Технология CURL</h3><hr><hr>' . "<br>";
/*Введение:
Технология CURL - позволяет  взаимодействовать со сторониими серверами и брать от них какую либо информацию либо передавать ее на них. 
Для работы с CURL всегда нужно сначала открыть соединение - далее внести необходимые настройки - затем закрыть соединение.

	ПРИНЯТИЕ ДАННЫХ ЧЕРЕЗ CURL
		$curl = curl_init(); //функция запуска CURL
		curl_setopt($curl, CURLOPT_URL, 'https://kipmu.ru/sovy/'); //функция записи настроек ... 
			Первым параметром выступает подключение к CURL. Вторым название передаваемой настройки. Третим адрес URL сайта с которого принимаются данные. С этого сайта будет изъят HTML.
		curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); //функция записи настроек с настройкой, позволяющей отображать сайты с протоколом HTTPS
		curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); //функция записи настроек с настройкой, позволяющей поместить весь HTML код в переменную. 
			Весь код HTML помещается в переменную для того, чтобы можно было выбирать момент его вывода.

		$result = curl_exec($curl); //функция выполнения CURL запроса ... переменная ставится только при наличии настройки помещающей HTML код в переменную.
		curl_close($curl); //функция закрытия CURL
			После запуска и выполнения CURL всегда должен закрываться. Единственным аргументом функции выступает переменная с функцией запуска CURL.
		$section = explode('<a href="https://kipmu.ru/pticy-podmoskovya/" target="_self" rel="dofollow" class="u5d1500033fdb22743401eae9170a12e0" data-wpel-link="internal">', $result);	//функция разбивает HTML код на ключевые слова и символы (начало кода). Делит весь HTML на код до выбранного кода и после выбранного кода на элементы массиваэ
			Первым аргументом выступает текст, разделяющий код на разделы. Вторым аргументом является переменная, вмещающая код.
		$section_2 = explode('</a>', $section[1]);	//функция разбивает HTML код на ключевые слова и символы (конец кода)
			Текст от выбранной строки разделяем по завершающему тегу. Теперь выбран только нопределенный блок во всем коде HTML.
		echo $section_2[0]; //вывод переменной с HTML кодом. Это возможно с настройкой CURLOPT_RETURNTRANSFER

	ПЕРЕДАЧА ДАННЫХ ЧЕРЕЗ CURL
		$curl = curl_init(); //функция запуска CURL
			$peredach = array('name' => 'cookie_set');					//передаваемые данные
		curl_setopt_array(); - функция аналогичная "curl_setopt", но передающая настройки не массивом, а не по одной.
		CURLOPT_URL => 'http://kurs-itproger-backend/cookie.php',	//сайт-получатель информации
		CURLOPT_RETURNTRANSFER => true,										//передаваемые данные помещаются в переменную, а не выводятся сразу
		CURLOPT_POST => true,													//данные передаются методом POST
		CURLOPT_POSTFIELDS => http_build_query($peredach)				//передаваемые параметры. Функция позвлдяющая корректно передать все данные  
		$result_2 = curl_exec($curl); 										//помещаем все передаваемое в переменную
		curl_close($curl); //функция закрытия CURL
		*/

/*Прием данных*/
$curl = curl_init(); //функция запуска CURL
curl_setopt($curl, CURLOPT_URL, 'https://kipmu.ru/sovy/'); //функция записи настроек 
curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); //функция записи настроек с настройкой, позволяющей отображать сайты с протоколом HTTPS
curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); //функция записи настроек с настройкой, позволяющей поместить весь HTML код в переменную 

$result = curl_exec($curl); //функция выполнения CURL запроса ... переменная ставится только при наличии настройки помещающей HTML код в переменную.
curl_close($curl); //функция закрытия CURL

$section = explode('<div class="tds-message-box box-note">', $result);	//функция разбивает HTML код на ключевые слова и символы (начало кода)
$section_2 = explode('</div>', $section[1]);	//функция разбивает HTML код на ключевые слова и символы (конец кода)
echo $section_2[0]; //вывод переменной с HTML кодом. Это возможно с настройкой CURLOPT_RETURNTRANSFER


/*Передача данных
$curl = curl_init(); //функция запуска CURL
$peredach = array('name' => 'cookie_set');								//передаваемые данные ... данные будет передавать в куки сайта

curl_setopt_array(
	$curl,
	array(
		CURLOPT_URL => 'http://kurs-itproger-backend/cookie.php',	//сайт-получатель информации...страницы куки на локальном сервере
		CURLOPT_RETURNTRANSFER => true,										//передаваемые данные помещаются в переменную, а не выводятся сразу
		CURLOPT_POST => true,													//данные передаются методом POST
		CURLOPT_POSTFIELDS => http_build_query($peredach)				//передаваемые параметры. Функция позвлдяющая корректно передать все данные  
	)
); //функция передает целый массив настроек, а не одну как "curl_setopt"

$result_2 = curl_exec($curl); 												//помещаем все передаваемое в переменную
curl_close($curl); //функция закрытия CURL
echo $_COOKIE['myCookie']; // вывод значения куки полученного через CURL. 
ВАЖНО! На локальном серезвере технология CURL работает не корректно. Поэтому данне могут некорректно приниматься и передаваться (например в виде бесконечной загрузки).
*/

echo '<hr><hr><br><h3>Back - #2.10 - PHP 8 – особенности новой версии</h3><hr><hr>' . "<br>";
/*Введение:

	СПИСОК НОВШЕСТВ В PHP 8. В версиях менььше 8-й они вызывают ошибки.
		1. Jit (Just in time/компеляция налету).
				Это технология компелирования части интерпретируемого кода. Который становится чем то вроде КЕШа. Эта технология встроена и ничего для ее задействования в делать не нужно. 

		2.1) Поля теперь можно создавать примяком внутри самого конструктора, когда как раньше в конструкторе можно было только присваивать полученные значения к объектам класса. Это удобно и сокращает код. 
			Пример как стало: 
				function __construct( //поля могут создаваться примяком в самом конструкторе...в месте получения параметров указыватся и создание полей.
				public $x = 0,
				public $y = 0.0,	//последний ноль игнорируется
				public $z = 0,		//запятая может ставится после последнего элемента..это не выдает ошибок.
				){}
		2.2) Теперь можно использовать именованные аргументыы. В функциях, методах, конструктарах можно указывать куда конкретно передаются полаемые значения. 
				Если какие то значение при создании поля будут не указаны - в конструкторе их можно указать по-умолчанию, если они не были указаны при создании поля.
		2.3) Теперь в переменной или поле можно указать какой тип данных предпологается там для хранения. И в случаи несоответствия типа - выдается ошибка. 
			Пока не точно, но похоже это относится только к классам. На объекты вне классов это возможно не распространяется.
			Пример:
			public int|float $x = 0, ... при вводе нечислового значени выдается ошибка. Число в кавычках тоже счтается числом.

		3. Обновась конструкция "Switch-case":
			3.1) В 8-й версии PHP появилась новая конструкция, которая позволит сверять не только значение, но и тип данных. То есть если в кейсе указано число в скобках, то число без скобок не пройдет проверку. 
		
		4. Многоступенчатые условия можэно теперь записывать в такой код: 
		$country = $session?->$user?->getAddress()?->$adres?->country; //если переменные не равны $country(null), то код выполняется дальше.
		
		5.До 8-й версии PHP выражение считалось истинной 
		0 == 'str' //true - до 8-й версии
		0 == 'str' //false - от 8-й версии

		6. Появилась возможность передавать неограниченное (неопределенное) количество параметров внутрь функции или метода, находящегося внутри класа.
		Теперь все параметры внесенные в функцию записываюстя автоматически в массив. 
		Так же при необходимости можно добавить обязательынй параметр, без которого функция не заработает. Он ставится перед массивом.
		Пример: 
		//Новый способ
			function printUnfo($sql, ...$params)
			{
				foreach ($params as $value) {
					echo 'Значение параметра функции: ' . $params;
				}
			}
		
		*/
//примеры нововведений на классе
//старый формат записи
class new_8
{
	public $x;
	public $y;
	public $z;

	function __construct($x, $y, $z)
	{
		$this->x = $x;
		$this->y = $y;
		$this->z = $z;
	}
}
$kord = new new_8(4, 7, 12);

//новый формат записи
//class new_8
//{
//	function __construct( //поля могут создаваться примяком в самом конструкторе...в месте получения параметров указыватся и создание полей.
//		public int|float $x = 0,
//		public int|float $y = 0.0,	//последний ноль игнорируется
//		public int|float $z = 0,		//запятая может ставится после последнего элемента..это не выдает ошибок.
//	) {
//	}
//}
//$kord = new new_8(x: 4, y: 7, z: 12); //теперь при указания аргумента поля - можно указывать и название самого поля. (без знака $)

echo 'Координаты: x = ' . $kord->x . '; y = ' . $kord->y . '; z = ' . $kord->z . '<br>';


//Обновленный switch-case
//Старая версия
$per_switch = 25;
switch ($per_switch) {
	case 'двадцать пять':
		$result = '<br>25 строка<br>';
		break;

	case '25':
		$result = '<br>Не число, а строка<br>';
		break;
}
echo $result;


//Новая версия
//$per_switch = 25;
//$result = match ($per_switch) {
//	'25' => '25 это строка',
//	25  => '25 это число',
//};
//echo $result;


//Новый способ записи условия с объектаим (при наличии объектов)
//$country = null;
//if ($session != null) {
//	$user = $session->user;
//}
//if ($user != null) {
//	$adress = $user->getAddress();
//}
//if ($adres != null) {
//	$country = $adres->$country;
//}
////вся эта запись равносильна одной строке
//$country = $session?->$user?->getAddress()?->$adres?->country; //если переменные не равны $country(null), то код выполняется дальше.


//Способ передачи неограниченного (неопределенного) числа параметров в функцию
//Старый способ
function printInfo($str_1, $str_2, $str_3)
{
	echo "<br>Вывод значений функции: 
	Первое: $str_1, Второе: $str_2, Третье: $str_3";
}

//Новый способ
//function printInfo($sql,...$params)
//{
//	foreach ($params as $value) {
//		echo 'Значение параметра функции: ' . $params . '<br>';
//	}
//}
printInfo('Первый', 'Второй', 'Третий');

?>
</body>

</html>