<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Тайтл</title>
</head>

<body></body>
<header>
	Шапка сайта
</header>
<footer>Подвал сайта</footer>
<?php
echo '<hr><hr><br><h2>Модуль №4: Создание блога. Главная страница и система регистрации
</h2>' . "<br>";
echo '<hr><hr><br><h3>Back - #4.1-5 - Как работает Интернет? Протоколы, домены и прочие вещи</h3><hr><hr>' . "<br>";
/*Введение:
	Домен		- это человеко понятный адрес сайта
		Домен состаит из:
			а) Субдомена
			б) Название
			в) Уровень (тип домена)
				Субдомены	- это приставка домена, позволяющая обойтись без создания дополнительного подраздела домена для подраздела уже имеющегося сайта. 
				Название		- это псевдоним, заменяющий адрес сайта понятного для провайдера (ip адрес сервера сайта) на тот, который понятен человеку.  
				Уровень		- это разновидность типов доменов
					а) Верхний уровень: ".сom", ".net", ".org".
					б) Национальный уровень: ".ru", ".us", ".ua".
					d) Общий уровень: ".edu", ".ni", ".io"
	Хостинг - это место на сервере, выделенное на хранение сайта. 
	Протоколы данных - технология, служащая для указания формата передачи данных. 
		Типы протоколов:
			"http"	- 	протокол передачи WEB данных (для отображения сайта).
			"SSL"		-	протокол защищающий передачу данных пользователя (логин/пароль/номер карты/адрес и т.п.).  
			"TLS"("https")	- обновленный "SSL" - защищенная версия проокола http. Подключается через хостинг-провайдера (сервис, обеспечивающий выгрузку сайта на сервер).
			"FTR"(file transfer protocol)	- протоколо, используемый при прямой передачи данных между сервером и клиентом. Обычно используется для выгрузки сайта на сервер. 
			"SMTP"(Simple Mail Transfer Protocol)	-	протокол используется для работы с почтой. 
			"TСP"(Transmission Control Protocol)	-	протокол используется для прямой передачи данных от одного сервера к другому.
			"RTP"(Real-time Transport Protocol)		- 	протокол для передачи данных в реальном времени (стриминг, IP-телефония, просмотр online видео).
			*/

			echo '<hr><hr><br><h3>Back - #4.3 - Регистрация на сайте и добавление в БД
			</h3><hr><hr>' . "<br>";
			/*Введение:
			В ходе урока будет создана специальная страница с формой регистрации на языке HTML. Все полученные данные из формы будут обрабатываться на различные ошибки при помощи языка PHP. Далее все данные будут помещены в базу данных при помощи технологии PDO.
		
			ПОДКЛЮЧЕНИЕ ФАЙЛОВ
			Создадим странички, где будет регестрироваться новый пользователь (reg.php) и будут обрадатываться его данные (reg/reg.php).
			Предварительно поместим подключения к css, бутстрап и прочее в отдельный файл и подключим его.
			Заглавие страници оставит тоже в хеде, но нна страницах оставим название переменной, которая будет использоваться в хеде.
			Пример:
			<title><?=$site_title?></title> - это код внутри хеда (в файлике).
			<?php $site_title = 'Главная страница'; require 'blocks/head.php'?> - это код оставленный за место хеда.
		
			HTACCESS
			ЧПУ человеку понятный URL.
			При переходе на ту или иную страницу на сайте вадресной строке отображается навание файла с форматом ".php". 
			Это не красиво, поэтому в файле "htaccess" допишем строку - дерективу RewriteRule:
			RewriteRule ^reg?$ reg.php [NC, L], где RewriteRule - деректива переадресации, ^reg?$ - название заменяющее название файла (без знаков ^?$). reg.php - заменяемое имя файла. [NC, L] - настройка подтверждающая, что при переходе на этот файлик будет переадресация на выбранное название (вне зависимости от регистра).
			
			ВНИМАНИЕ! Эта настройка работает на веб-хостинге, но при вызове ее на локальном сервере - настройка может вызывать ошибку 500. 
		
			Если на локальном сервере OpenServer подключить модуль в .htaccess, но ошибка может не появиться.
			Пример вызова модуля:
				<IfModule mod_rewrite.c>
				RewriteEngine on
				RewriteBase /
				</IfModule>
			
			При работающем модуле - развания в файлов в ссылках можно менять на название, выбранное в .htaccess. 
			Пример:
			 href="/reg.php"	- было
			 href="/reg"		- стало
		
			 СОЗДАНЕИ ФОРМЫ
			 На странице регистрации создадим форму, данные которой будут обрабатываться в файле "reg.php" =>
			 <form action="reg/reg.php" method="post">. 
			При создании кнопки нужно выбирать тип "submit", так как с типом "button" - страница не перезагружается (данные отправляться не будут).
		
			ОБРАБОТЧИК
			Первым делом нужно поставить фильтр на получаемые данные из формы, чтобы избежать инъекции и иной непредусмотренной записи (SQL или HTML кода).
		
			Фильтры на поля выглядят так:
				$username = trim(filter_var($_POST['username'], FILTER_SANITIZE_STRING));
				$email = trim(filter_var($_POST['email'], FILTER_SANITIZE_EMAIL));
				$login = trim(filter_var($_POST['login'], FILTER_SANITIZE_STRING));
				$password = trim(filter_var($_POST['password'], FILTER_SANITIZE_STRING));
				где,  
				filter_var - функция фильтрации. 
				$_POST['username'] - первый аргумент функции - это полученные из формы данные.
				FILTER_SANITIZE_STRING - тип фильтрации. Выбираетс яв зависимости от полученной информации. Для строковой информации выбирается фильтр FILTER_SANITIZE_STRING, а для почты FILTER_SANITIZE_EMAIL. Для URL  другйо фильтр.
				trim - функция, обрезающая лишние пробелы вокруг текста.
		
				Проверка информации из формы.
				Когда информация отфильтрована на наличие нежелательного кода можно приступать к проверке содержимого. 
				Но эта проверка подробнее будет рассматриваться в следующем уроке по Ajaks.
				Сейчас просто поставим ограничение в 3 символа:
		
				if ( mb_strlen($username) <= 3){		// mb_strlen - функция подсчета числа символов, учитывая кириллицу
					exit();
				} else if( mb_strlen($email) <= 3){
					exit();
				} else if ( mb_strlen($login) <= 3) {
					exit();
				} else if ( mb_strlen($password) <= 3){
					exit();
				}
				
				Хеширование пароля
				Пароль это данные, требующие дополнительной защиты. Эту защиту обеспечивает функция md5, хеширующая пароль. Для полного эффекта к этой функции прибавляется "соль" - набор случайных символов, который приписывается к основному паролю при хешировании для усилении защиты пароля. В БД записывается хешированный пароль.
				Пример:
					//хеширование пароля
						$hash_salt = "q3t7olugea"; //соль
						$hash_pass = md5($password . $hash_salt); //захешированный пароль
		
				При попытке ввода пароля зарегистрировавшегося пользователя - он (парольь) так же складывается с солью и хешируется. Если итоговый набор символов совпадает, с набором из БД, то значит пароль верный.
		
				Подключение к БД
				Подключение к БД производится по шаблону, который уже ррассматривался к блоке с по БД.
				Единственное, что нужно отметить: паролю нужно задавать в БД з2 символа, так как функция md5 всегда возвратщает 32 символа. 
				Пример:
					//подключение к БД
					$user = 'root'; 
					$pass = ''; 
					$db = 'kurs_php_mysql';
					$host = 'localhost';
					//$dsn = 'msql:host=' . $host . '; dbname=' . $db; - вариант без порта (не всегда рабочий)
					$dsn = 'mysql:host=' . $host . '; port=3306; dbname='. $db;
					$pdo = new PDO($dsn, $user, $password);
					//запрос
					$sql = 'INSERT INTO users_p (name, email, login, pass) VALUES (?, ?, ?, ?)';
					$query = $pdo->prepare($sql);
					$query->execute([$username, $email, $login, $hash_pass]);
				*/
				echo '<hr><hr><br><h3>Back - #4.4 - Ajax регистрация (асинхронное программирование)
				</h3><hr><hr>' . "<br>";
				/*Введение:
				PHP работает на стороне сервера, а это означает, что для связи с ним приходиться обновлять страницу в браузере. Благо существует асинхронное программирование и библиотека Ajax, которые позволяют отправить данные на сервер без перезагрузки страницы.
				Ajax - технология, позволяющая отсылать запрос на другие страницы без перезагрузки самой страницы. Это очень удобно, так как при помощи подобного функционала вы можете создать различные формы обратной связи, которые будут добавлять комментарии или делать любую другую работу без перезагрузки страницы.
		
				ПОДКЛЮЧЕНИЕ ajax.
				Это jqury библиотека, значит ее нужно подключать в самый низ страницы. А еще ниже напишем сам ajax и его запрос к файлу обработчику PHP.
		
				ИЗМЕНЕНИЕ ФОРМЫ
				Но сначала нужно повечить на кнопку в форме регистрации айдишник, который при нажатии на кнопку будет запускать ajax. 
				При этом тип кнопки можно заменить с "submit" на "button" Так как обновление страницы более не понадобтся. И добавить кнопке if="", на который будет ссылаться ajax, при выполнении запроса.  
				Так же из таблицы можно не указывать метод и action, так как адрес обработчика и метод передачи данных будет указаны в ajax - запросе.
				AJAX ЗАПРОС
					 //1-я часть написания ajax запроса - принятие параметров из формы
					 $('#reg_user').click(function(){ //при нажатии на кнопку(click) с айдишником "reg_user" начинать обработку функции.
						var name = $('#username').val();		//var name - переменная JS.
						var email_per = $('#email').val();	//$('#email').val(); - значение поля формы с id="email".
						var login_per = $('#login').val();
						var password_per = $('#password').val();
						//var - в JS это обозначение переменной, а val - значение. Т.е. строки обозначают: поместить в переменную "name" (var name) - значение поля из формы с айдишником "username" ($('#username')). И так со всеми полями. При этом функции не нужно указывать имя (click(function(){}).
						То есть первый шаг в написании ajax запроса - это помещение значений полей в переменные.
		
				//2-я часть написания ajax запроса - принятие параметров из формы.
				Когда все данные из формыполучены - их можно передавать обработчику PHP "registr.pgp". 
				Но для этого нужно заполнить несколько параметров на примере:
					$.ajax({								//наличие фигурных скобок указывает на объект ($.ajax).
					url: 'registr/registr.php',	//адрес обработчика
					type: 'POST',						//метод передачи обработчику
					cache: false,						//настройка кеширования
					data: {'username': name, 'email': email_per, 'login': login_per, 'password': password_per}, //данные, где 'username': - название id поля в форме, а : name, - значение поля из формы. Если в первой части запроса данне собирались в запрос, то сейчас они передаются обработчику.
					dataType: 'html',					//способ получения данных
					//beforeSend: funcrion(){} - данные обработанные до возвращения ответа от сервера. Пропустим.
					success: function(data){		//success - это функция, обрабатываемая после получения ответа от обработчика. Где аргументом всегда выступает "data". Data - это любое сообщение, полученное от отработчика через оператор echo. Сообщение "готово" ставится после выполнения всех операция по добавлению пользователя в БД. Т.е. в самом конце обработчика.
						if (data == 'готово'){		//если обработчик прислал сообщение "готово" через оператор echo.
							$('#successMessage_reg').show();	//открытие скрытого элемента с id=successMessage_reg
							$('#successMessage_reg').text('Регистрация успешно завершена'); //вывод сообщение в блоке с id=successMessage_reg
							$('#errorMessage_reg').hide();	//скрытие блока с опоещением о ошибке
						}else{	//если обработчик НЕ прислал сообщение "готово" через оператор echo. Т.е. прислал ошибку.
							$('#errorMessage_reg').show();		//открытие скрытого элемента с id=errorMessage_reg
							$('#errorMessage_reg').text(data);	//вывод сообщение в блоке с id=errorMessage_reg 
							$('#successMessage_reg').hide();		//скрытие блока с оповещении о регистрации
						}
					}	*функция, обрабатываемая при получении ответа от сервера.
			Функция принимает в аргумент - сообщения, выводимые в обработчике оператором "echo". В том числе ошибке заполнения формы.
		
					В обработчике создадим переменную $error = ''; Чтобы через нее проверять наличие ошибки в заполнении формы. Если ошибок в форме не появится, то в обработчике выводить сообщение "готово".
				 });
		
		
				*/
		
				echo '<hr><hr><br><h3>Back - #4.5 - Авторизация и выход с учетной записи
				</h3><hr><hr>' . "<br>";
				/*Введение: 
				На этом этапе мы проработаем форму с авторизацией пользователя на сайте. Мы научимся сохранять вход пользователя в куки и в зависимости от значений в них выдавать разную информацию на сайте. Помимо авторизации и сохранения данных в куки, мы также научимся удалять данные из куки и выходить из учетной записи пользователя.
				
				СОЗДАНИЕ ФАЙЛА АВТОРИЗАЦИИ
				Первым делом в файле "header" добавим сыслку на новый файл авторезации "auth.php".
				Перенесем в него все содержимое из файла регистрации "reg.php". Удаляем все поля кроме логина/пароля и оповещения о авторизации/ошибке. Заменяем id кнопки "auth.php", так как аякс будет на нее реагировать.
				 Изменим адрес передачи обработчику, так как за авторзацию будет отвечать другой обработчик.
				 Позже  в параметре success припищем возможность перехода на другую страницу после авторезации.
				Заменим название папки registr на handler-ajax, так как в теперь будет находиться не только файл регистрации.
		
				 СОЗДАНИЕ ОБРАБОТЧИКА АВТОРИЗАЦИИ
				 Собержимое обработчика регистрации копируем в обработчик авторизации, оставляя лишь данные о логине-пароле.
				 Подключение к БД поместим в отдельный файл, чтобы уже его подключать к другим обработчикам. Так как данные подключения придется регулярно обновлять. 
				 И лучше это делать в одном месте. 
				 Пример: require_once '../msql_connect.php';, где require_once - ограничение в одно плдключение к файлу.
				
				За подключением следует запрос и его выполнение:
				$sql = 'SELECT `id` FROM `users_p` WHERE `login` = :login && `pass` = :pass';
				$query = $pdo->prepare($sql);
				$query->execute(['login' => $login, 'pass' => $password]);
				Для вывода результата нужно создать переменную и прописать метод вывода результата запроса.
				$useer = $query->fetch(PDO::FETCH_OBJ);	//строка нужная для вывод информации - когда нужно просто удалить данные или поменять это строка не нужна. 
		
				ПОМЕЩЕНИЕ ДАННЫХ ПОЛЬЗОВАТЕЯ В COOKIE
				Когда пользователь авторизовался - для удобства его данные помещаются в кууки.
				//если такого пользователянет - иначе. +Добавление данных пользователя в cookie.
			if ($useer->id == 0 ) { //если выдает такое условие выдает ошибку, то переписать его: if($query->rowCount() == 0) , где rowCount - функция подсчета строк
				echo 'Неверный пароль либо данный пользователь не зерегистрирован на сайте';
			}else{
				setcookie('cookie_log', $login, time() + 3600*24*7, "/"); 
				// 4-й параметр отвечает за зону действия куки. На весь сайт, на папку или на отдельную страницу.
				//неделя на хранение логина пользователя . Пароль заносить в кууки не будем.
				echo 'готово'; }
				
		
				ПЕРЕДЕЛКА СТРАНИЦЫ АВТОРИЗАЦИИ В СТРАНИЦУ ПОЛЬЗОВАТЕЛЯ
				//ПЕРЕПИСЬ ПАРАМЕТРА SUCCESS В AJAX
				В параметре success добавим команду перезагрузки страницы в случаи авторизации:
				document.location.reload(true);	//перезагрузка страницы
				При этом после перезагрузки страницы - куки уже будут установлены.
				Напишем вставку над таблицей, позволявшая убрать таблицу авторизации в случаи ее успеха:
				<!--начало условия-->
				<?php if ($_COOKIE['cookie_log'] == 0):  //знак ":" - это начало тела условия ?>
					... форма ... 
		
				<!--иначе-->
				<?php else:;  //код, срабатывающий при авторезации; ?>
						<h2>Пользователь с логином "<b><?=$_COOKIE['cookie_log']; ?></d> => авторизован"</h2>
		
				<!--конец условия-->
				<?php endif;  //endif; - это конец тела условия ?>
					ВАЖНО! При написании строчки "($_COOKIE['cookie_log'] == 0):" - может выдаваться ошибка. Это связано с версиями PHP и выборам локального сервера.
					Если ошибка выдаеться, то условие записывать так: if(!isset($_COOKIE['cookie_log'])): ... где isset - функция проверки ключа на наличие.
				Если куки заработала, то формы должна замениться, то, что прописано ниже "else". Так как условием появления формы являлось отсутствие куки. Т.е. авторезации.
				Нижу else можно прописать уже другую форму, но пропишем это либо в другом уроке, либо просто приветствие c кнопкой выхода в хедере.
		
				ДОБАВЛЕНИЕ AJAX ДЛЯ КНОПКИ ВЫХОДА 
				После авторизаци доабвим ajax - запрос. 
				В нем не будет данных, которые передаются на обработчик (сервер).
				Просто при получении ответа об авторизации пользоваателя - будет перезапускаться страница. 	
				Пример:
				$('#auth_exit').click(function() {			
				$.ajax({
				url: 'handler-ajax/exit.php',	//адрес обработчика
				type: 'POST',						//метод передачи обработчику
				cache: false,						//настройка кеширования
				data: {}, 
				dataType: 'html',					
				success: function(data){	
					if (data == 'готово'){					
						document.location.reload(true);	//перезагрузка страницы
				
					}}});});
				Ссылаться ajax будет на файл "exit.php", котоырй будет обнулять куки при выходе из аккаунта.
				Немного о методе "reload":
					reload() - перезагружает текущий документ. 
					Метод reload() имеет один необязательный параметр булевского типа. Если в качестве параметра указать 	значение true, то страница будет принудительно обновлена с сервера. А если параметр не указывать или использовать в качестве параметра значение false, то браузер может обновить страницу, используя данные своего кэша. Метод reload() "имитирует" нажатие кнопки обновить в браузере.	
					Т.е. метод принимает параметры либо true либо false.
		
				ЗАМЕНА КНОПОК В ХЕДЕРЕ ПОСЛЕ АВТОРИЗАЦИИ
				После авторезации заменим в хедере кнопки "войти" и "заргистрироваться" на кнопку "Личный кабинет".
				Замена кнопок происходит так же как и замена формы на кнопку выхода - через проверку куки. 
				Пример:
					<!--НАЧАЛО УСЛОВИЯ-->
				<?php if ($_COOKIE['cookie_log'] == 0):  //знак ":" - это начало тела условия. Скобки не единственный способ определения тела условия. ?>
				  <a class="btn btn-sm btn-outline-secondary mr-2 " href="/auth.php">Войти</a>
				  <a class="btn btn-sm btn-outline-secondary " href="/reg.php">Зарегистрироваться</a>
					<!--ИНАЧЕ-->
				<?php else:;  //код, срабатывающий при авторезации; ?>	
				<a class="btn btn-sm btn-outline-secondary " href="/auth.php">Личный кабинет</a>
					<!--КОНЕЦ УСЛОВИЯ-->
				<?php endif;  //endif; - это конец тела условия ?>
				Теперь при авторизации кнопки "войти" и "зарегистрироваться" заменяются на кнопку "личный кабинет" в случаи если куки определенного типа заполнена.
				*/

?>
</body>

</html>